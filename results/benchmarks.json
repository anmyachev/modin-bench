{
    "benchmarks.TimeAppend.time_append": {
        "code": "class TimeAppend:\n    def time_append(self, shapes, sort):\n        execute(self.df1.append(self.df2, sort=sort))\n\n    def setup(self, shapes, sort):\n        self.df1 = generate_dataframe(\n            ASV_USE_IMPL, \"int\", *shapes[0], RAND_LOW, RAND_HIGH\n        )\n        self.df2 = generate_dataframe(\n            ASV_USE_IMPL, \"int\", *shapes[1], RAND_LOW, RAND_HIGH\n        )\n        if sort:\n            self.df1.columns = self.df1.columns[::-1]",
        "min_run_count": 2,
        "name": "benchmarks.TimeAppend.time_append",
        "number": 0,
        "param_names": [
            "shapes",
            "sort"
        ],
        "params": [
            [
                "((5000, 5000), (5000, 5000))",
                "((500000, 20), (1000000, 10))"
            ],
            [
                "False",
                "True"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "c2d89eb99a9d7965ff21009a90377a267577d695e1baeeedba0a97d62f2f8030",
        "warmup_time": -1
    },
    "benchmarks.TimeArithmetic.time_apply": {
        "code": "class TimeArithmetic:\n    def time_apply(self, shape, axis):\n        execute(self.df.apply(lambda df: df.sum(), axis=axis))\n\n    def setup(self, shape, axis):\n        self.df = generate_dataframe(ASV_USE_IMPL, \"int\", *shape, RAND_LOW, RAND_HIGH)",
        "min_run_count": 2,
        "name": "benchmarks.TimeArithmetic.time_apply",
        "number": 0,
        "param_names": [
            "shape",
            "axis"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ],
            [
                "0",
                "1"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "219317b7fcbaf3f87050bca6999e1b68c258853598a859ac59da82b025bf251a",
        "warmup_time": -1
    },
    "benchmarks.TimeArithmetic.time_mean": {
        "code": "class TimeArithmetic:\n    def time_mean(self, shape, axis):\n        execute(self.df.mean(axis=axis))\n\n    def setup(self, shape, axis):\n        self.df = generate_dataframe(ASV_USE_IMPL, \"int\", *shape, RAND_LOW, RAND_HIGH)",
        "min_run_count": 2,
        "name": "benchmarks.TimeArithmetic.time_mean",
        "number": 0,
        "param_names": [
            "shape",
            "axis"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ],
            [
                "0",
                "1"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b541392002bd635e8fdf6d069d1fb9147bf2e0d1cbccf130bf1b596c17454708",
        "warmup_time": -1
    },
    "benchmarks.TimeArithmetic.time_median": {
        "code": "class TimeArithmetic:\n    def time_median(self, shape, axis):\n        execute(self.df.median(axis=axis))\n\n    def setup(self, shape, axis):\n        self.df = generate_dataframe(ASV_USE_IMPL, \"int\", *shape, RAND_LOW, RAND_HIGH)",
        "min_run_count": 2,
        "name": "benchmarks.TimeArithmetic.time_median",
        "number": 0,
        "param_names": [
            "shape",
            "axis"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ],
            [
                "0",
                "1"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "6f99b2ce6d39b39818206977c6513e7df8166e01bbff37724a82601a9c4875ad",
        "warmup_time": -1
    },
    "benchmarks.TimeArithmetic.time_nunique": {
        "code": "class TimeArithmetic:\n    def time_nunique(self, shape, axis):\n        execute(self.df.nunique(axis=axis))\n\n    def setup(self, shape, axis):\n        self.df = generate_dataframe(ASV_USE_IMPL, \"int\", *shape, RAND_LOW, RAND_HIGH)",
        "min_run_count": 2,
        "name": "benchmarks.TimeArithmetic.time_nunique",
        "number": 0,
        "param_names": [
            "shape",
            "axis"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ],
            [
                "0",
                "1"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "2e6aa9b726c293d7e2d3121d8ad006add467a8da0531eac8774b3f0384ca64bc",
        "warmup_time": -1
    },
    "benchmarks.TimeArithmetic.time_sum": {
        "code": "class TimeArithmetic:\n    def time_sum(self, shape, axis):\n        execute(self.df.sum(axis=axis))\n\n    def setup(self, shape, axis):\n        self.df = generate_dataframe(ASV_USE_IMPL, \"int\", *shape, RAND_LOW, RAND_HIGH)",
        "min_run_count": 2,
        "name": "benchmarks.TimeArithmetic.time_sum",
        "number": 0,
        "param_names": [
            "shape",
            "axis"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ],
            [
                "0",
                "1"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "3ade96bfe969295a9d3c99d61bc88dedda36a799925710d5620e5fb30438d074",
        "warmup_time": -1
    },
    "benchmarks.TimeAstype.time_astype": {
        "code": "class TimeAstype:\n    def time_astype(self, shape, dtype, astype_ncolumns):\n        execute(self.df.astype(self.astype_arg))\n\n    def setup(self, shape, dtype, astype_ncolumns):\n        self.df = generate_dataframe(ASV_USE_IMPL, \"int\", *shape, RAND_LOW, RAND_HIGH)\n        if astype_ncolumns == \"all\":\n            self.astype_arg = dtype\n        elif astype_ncolumns == \"one\":\n            self.astype_arg = {\"col1\": dtype}\n        else:\n            raise ValueError(\"astype_ncolumns: {astype_ncolumns} isn't supported\")",
        "min_run_count": 2,
        "name": "benchmarks.TimeAstype.time_astype",
        "number": 0,
        "param_names": [
            "shape",
            "dtype",
            "astype_ncolumns"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ],
            [
                "'float64'",
                "'category'"
            ],
            [
                "'one'",
                "'all'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "e0815604b1644fa44789102d06d841ad6e2d03792cc5d694a40c0838ae3275f3",
        "warmup_time": -1
    },
    "benchmarks.TimeBinaryOp.time_binary_op": {
        "code": "class TimeBinaryOp:\n    def time_binary_op(self, shapes, binary_op, axis):\n        execute(self.op(self.df2, axis=axis))\n\n    def setup(self, shapes, binary_op, axis):\n        self.df1 = generate_dataframe(\n            ASV_USE_IMPL, \"int\", *shapes[0], RAND_LOW, RAND_HIGH\n        )\n        self.df2 = generate_dataframe(\n            ASV_USE_IMPL, \"int\", *shapes[1], RAND_LOW, RAND_HIGH\n        )\n        self.op = getattr(self.df1, binary_op)",
        "min_run_count": 2,
        "name": "benchmarks.TimeBinaryOp.time_binary_op",
        "number": 0,
        "param_names": [
            "shapes",
            "binary_op",
            "axis"
        ],
        "params": [
            [
                "((5000, 5000), (5000, 5000))",
                "((500000, 20), (1000000, 10))"
            ],
            [
                "'mul'"
            ],
            [
                "0",
                "1"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "9ff776f725432c65f49e1c3f59022f6f3d976278510bf9915fda51ba51ad13ae",
        "warmup_time": -1
    },
    "benchmarks.TimeConcat.time_concat": {
        "code": "class TimeConcat:\n    def time_concat(self, shapes, how, axis):\n        execute(IMPL[ASV_USE_IMPL].concat([self.df1, self.df2], axis=axis, join=how))\n\n    def setup(self, shapes, how, axis):\n        self.df1 = generate_dataframe(\n            ASV_USE_IMPL, \"int\", *shapes[0], RAND_LOW, RAND_HIGH\n        )\n        self.df2 = generate_dataframe(\n            ASV_USE_IMPL, \"int\", *shapes[1], RAND_LOW, RAND_HIGH\n        )",
        "min_run_count": 2,
        "name": "benchmarks.TimeConcat.time_concat",
        "number": 0,
        "param_names": [
            "shapes",
            "how",
            "axis"
        ],
        "params": [
            [
                "((5000, 5000), (5000, 5000))",
                "((500000, 20), (1000000, 10))"
            ],
            [
                "'inner'"
            ],
            [
                "0",
                "1"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "718c07f0450388e6f586cf10e7466f364cc94e4a6909380b7f50d8213c45205c",
        "warmup_time": -1
    },
    "benchmarks.TimeDescribe.time_describe": {
        "code": "class TimeDescribe:\n    def time_describe(self, shape):\n        execute(self.df.describe())\n\n    def setup(self, shape):\n        self.df = generate_dataframe(ASV_USE_IMPL, \"int\", *shape, RAND_LOW, RAND_HIGH)",
        "min_run_count": 2,
        "name": "benchmarks.TimeDescribe.time_describe",
        "number": 0,
        "param_names": [
            "shape"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b06d1af039ee49fcea92c1e11a041c293d33b86c73874976592036d57e966eb8",
        "warmup_time": -1
    },
    "benchmarks.TimeDrop.time_drop": {
        "code": "class TimeDrop:\n    def time_drop(self, shape, axis, drop_ncols):\n        execute(self.df.drop(self.labels, axis))\n\n    def setup(self, shape, axis, drop_ncols):\n        self.df = generate_dataframe(ASV_USE_IMPL, \"int\", *shape, RAND_LOW, RAND_HIGH)\n        drop_count = (\n            int(len(self.df.axes[axis]) * drop_ncols)\n            if isinstance(drop_ncols, float)\n            else drop_ncols\n        )\n        self.labels = self.df.axes[axis][:drop_count]",
        "min_run_count": 2,
        "name": "benchmarks.TimeDrop.time_drop",
        "number": 0,
        "param_names": [
            "shape",
            "axis",
            "drop_ncols"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ],
            [
                "0",
                "1"
            ],
            [
                "1",
                "0.8"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "cbeb16adcb3fadd00159e6c9922ccbfaac0eb086cd953d0eebb36b89c3e6e266",
        "warmup_time": -1
    },
    "benchmarks.TimeFillna.time_fillna": {
        "code": "class TimeFillna:\n    def time_fillna(self, shape, limit, inplace):\n        kw = {\"value\": 0.0, \"limit\": self.limit, \"inplace\": inplace}\n        if inplace:\n            self.df.fillna(**kw)\n            execute(self.df)\n        else:\n            execute(self.df.fillna(**kw))\n\n    def setup(self, shape, limit, inplace):\n        pd = IMPL[ASV_USE_IMPL]\n        columns = [f\"col{x}\" for x in range(shape[1])]\n        self.df = pd.DataFrame(np.nan, index=pd.RangeIndex(shape[0]), columns=columns)\n        self.limit = int(limit * shape[0]) if limit else None",
        "min_run_count": 2,
        "name": "benchmarks.TimeFillna.time_fillna",
        "number": 0,
        "param_names": [
            "shape",
            "limit",
            "inplace"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ],
            [
                "None",
                "0.8"
            ],
            [
                "False",
                "True"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "24a895ac6bb572daba78946e1a36fa6506faf99ff85b15a830e08a44b46e7384",
        "warmup_time": -1
    },
    "benchmarks.TimeGroupByDefaultAggregations.time_groupby_count": {
        "code": "class TimeGroupByDefaultAggregations:\n    def time_groupby_count(self, *args, **kwargs):\n        execute(self.df.groupby(by=self.groupby_columns).count())\n\nclass BaseTimeGroupBy:\n    def setup(self, shape, ngroups=5, groupby_ncols=1):\n        if callable(ngroups):\n            ngroups = ngroups(shape[0])\n        self.df, self.groupby_columns = generate_dataframe(\n            ASV_USE_IMPL,\n            \"int\",\n            *shape,\n            RAND_LOW,\n            RAND_HIGH,\n            groupby_ncols,\n            count_groups=ngroups,\n        )",
        "min_run_count": 2,
        "name": "benchmarks.TimeGroupByDefaultAggregations.time_groupby_count",
        "number": 0,
        "param_names": [
            "shape",
            "ngroups"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ],
            [
                "100",
                "<function <lambda> at 0x7f2abcd06820>"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "92d3c87f3be7477b5f72e8e9b29e5567ed7ffbfc4769c85dd601447ec652b7a2",
        "warmup_time": -1
    },
    "benchmarks.TimeGroupByDefaultAggregations.time_groupby_mean": {
        "code": "class TimeGroupByDefaultAggregations:\n    def time_groupby_mean(self, *args, **kwargs):\n        execute(self.df.groupby(by=self.groupby_columns).mean())\n\nclass BaseTimeGroupBy:\n    def setup(self, shape, ngroups=5, groupby_ncols=1):\n        if callable(ngroups):\n            ngroups = ngroups(shape[0])\n        self.df, self.groupby_columns = generate_dataframe(\n            ASV_USE_IMPL,\n            \"int\",\n            *shape,\n            RAND_LOW,\n            RAND_HIGH,\n            groupby_ncols,\n            count_groups=ngroups,\n        )",
        "min_run_count": 2,
        "name": "benchmarks.TimeGroupByDefaultAggregations.time_groupby_mean",
        "number": 0,
        "param_names": [
            "shape",
            "ngroups"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ],
            [
                "100",
                "<function <lambda> at 0x7f2abcd06820>"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "73f1a1d2cc3137d5d46cf3561944757311c4ca04071176e01cbacf9e3d91ac17",
        "warmup_time": -1
    },
    "benchmarks.TimeGroupByDefaultAggregations.time_groupby_size": {
        "code": "class TimeGroupByDefaultAggregations:\n    def time_groupby_size(self, *args, **kwargs):\n        execute(self.df.groupby(by=self.groupby_columns).size())\n\nclass BaseTimeGroupBy:\n    def setup(self, shape, ngroups=5, groupby_ncols=1):\n        if callable(ngroups):\n            ngroups = ngroups(shape[0])\n        self.df, self.groupby_columns = generate_dataframe(\n            ASV_USE_IMPL,\n            \"int\",\n            *shape,\n            RAND_LOW,\n            RAND_HIGH,\n            groupby_ncols,\n            count_groups=ngroups,\n        )",
        "min_run_count": 2,
        "name": "benchmarks.TimeGroupByDefaultAggregations.time_groupby_size",
        "number": 0,
        "param_names": [
            "shape",
            "ngroups"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ],
            [
                "100",
                "<function <lambda> at 0x7f2abcd06820>"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "46cd8e2bf06cee874b4fb3ac64b53bbd1beae8c712e7be42877d1428d3c439ea",
        "warmup_time": -1
    },
    "benchmarks.TimeGroupByDefaultAggregations.time_groupby_sum": {
        "code": "class TimeGroupByDefaultAggregations:\n    def time_groupby_sum(self, *args, **kwargs):\n        execute(self.df.groupby(by=self.groupby_columns).sum())\n\nclass BaseTimeGroupBy:\n    def setup(self, shape, ngroups=5, groupby_ncols=1):\n        if callable(ngroups):\n            ngroups = ngroups(shape[0])\n        self.df, self.groupby_columns = generate_dataframe(\n            ASV_USE_IMPL,\n            \"int\",\n            *shape,\n            RAND_LOW,\n            RAND_HIGH,\n            groupby_ncols,\n            count_groups=ngroups,\n        )",
        "min_run_count": 2,
        "name": "benchmarks.TimeGroupByDefaultAggregations.time_groupby_sum",
        "number": 0,
        "param_names": [
            "shape",
            "ngroups"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ],
            [
                "100",
                "<function <lambda> at 0x7f2abcd06820>"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "7cb8ddef53de6ba0d5af512e85fe7a92615d7d1dc6ec6351b65d4de9bb03e09b",
        "warmup_time": -1
    },
    "benchmarks.TimeGroupByDictionaryAggregation.time_groupby_dict_agg": {
        "code": "class TimeGroupByDictionaryAggregation:\n    def time_groupby_dict_agg(self, *args, **kwargs):\n        execute(self.df.groupby(by=self.groupby_columns).agg(self.agg_dict))\n\n    def setup(self, shape, ngroups, operation_type):\n        super().setup(shape, ngroups)\n        self.cols_to_agg = self.df.columns[1:4]\n        operations = self.operations[operation_type]\n        self.agg_dict = {\n            c: operations[i % len(operations)] for i, c in enumerate(self.cols_to_agg)\n        }",
        "min_run_count": 2,
        "name": "benchmarks.TimeGroupByDictionaryAggregation.time_groupby_dict_agg",
        "number": 0,
        "param_names": [
            "shape",
            "ngroups",
            "operation_type"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ],
            [
                "100",
                "<function <lambda> at 0x7f2abcd06820>"
            ],
            [
                "'reduction'",
                "'aggregation'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "7aa41865cba30449bba2f4d9a40fe5d15e9d9b4c2c737222bd2a643fd6dcb39a",
        "warmup_time": -1
    },
    "benchmarks.TimeGroupByMultiColumn.time_groupby_agg_mean": {
        "code": "class TimeGroupByMultiColumn:\n    def time_groupby_agg_mean(self, *args, **kwargs):\n        execute(self.df.groupby(by=self.groupby_columns).apply(lambda df: df.mean()))\n\nclass BaseTimeGroupBy:\n    def setup(self, shape, ngroups=5, groupby_ncols=1):\n        if callable(ngroups):\n            ngroups = ngroups(shape[0])\n        self.df, self.groupby_columns = generate_dataframe(\n            ASV_USE_IMPL,\n            \"int\",\n            *shape,\n            RAND_LOW,\n            RAND_HIGH,\n            groupby_ncols,\n            count_groups=ngroups,\n        )",
        "min_run_count": 2,
        "name": "benchmarks.TimeGroupByMultiColumn.time_groupby_agg_mean",
        "number": 0,
        "param_names": [
            "shape",
            "ngroups",
            "groupby_ncols"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ],
            [
                "100",
                "<function <lambda> at 0x7f2abcd06820>"
            ],
            [
                "6"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "2dffb37454d689a6c30357ffbab52bce712cfe0030daf9f86e8bc99915ac3c63",
        "warmup_time": -1
    },
    "benchmarks.TimeGroupByMultiColumn.time_groupby_agg_quan": {
        "code": "class TimeGroupByMultiColumn:\n    def time_groupby_agg_quan(self, *args, **kwargs):\n        execute(self.df.groupby(by=self.groupby_columns).agg(\"quantile\"))\n\nclass BaseTimeGroupBy:\n    def setup(self, shape, ngroups=5, groupby_ncols=1):\n        if callable(ngroups):\n            ngroups = ngroups(shape[0])\n        self.df, self.groupby_columns = generate_dataframe(\n            ASV_USE_IMPL,\n            \"int\",\n            *shape,\n            RAND_LOW,\n            RAND_HIGH,\n            groupby_ncols,\n            count_groups=ngroups,\n        )",
        "min_run_count": 2,
        "name": "benchmarks.TimeGroupByMultiColumn.time_groupby_agg_quan",
        "number": 0,
        "param_names": [
            "shape",
            "ngroups",
            "groupby_ncols"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ],
            [
                "100",
                "<function <lambda> at 0x7f2abcd06820>"
            ],
            [
                "6"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "4f0a82458f5aca654b44a7f6ba206b9f902dfe6b54dfb1cbe31e63f798c6faef",
        "warmup_time": -1
    },
    "benchmarks.TimeHead.time_head": {
        "code": "class TimeHead:\n    def time_head(self, shape, head_count):\n        execute(self.df.head(self.head_count))\n\n    def setup(self, shape, head_count):\n        self.df = generate_dataframe(ASV_USE_IMPL, \"int\", *shape, RAND_LOW, RAND_HIGH)\n        self.head_count = (\n            int(head_count * len(self.df.index))\n            if isinstance(head_count, float)\n            else head_count\n        )",
        "min_run_count": 2,
        "name": "benchmarks.TimeHead.time_head",
        "number": 0,
        "param_names": [
            "shape",
            "head_count"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ],
            [
                "5",
                "0.8"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "0ab97d453eb88717822a7fbc0a43910d61e597489b0d1c49eec882656edd2dcf",
        "warmup_time": -1
    },
    "benchmarks.TimeIndexing.time_iloc": {
        "code": "class TimeIndexing:\n    def time_iloc(self, shape, indexer_type):\n        execute(self.df.iloc[self.indexer])\n\n    def setup(self, shape, indexer_type):\n        self.df = generate_dataframe(ASV_USE_IMPL, \"int\", *shape, RAND_LOW, RAND_HIGH)\n        if indexer_type == \"bool\":\n            self.indexer = [False, True] * (shape[0] // 2)\n        elif indexer_type == \"scalar\":\n            self.indexer = shape[0] // 2\n        elif indexer_type == \"slice\":\n            self.indexer = slice(0, shape[0], 2)\n        elif indexer_type == \"list\":\n            self.indexer = [x for x in range(shape[0])]\n        elif indexer_type == \"function\":\n            self.indexer = lambda df: df.index[::-2]",
        "min_run_count": 2,
        "name": "benchmarks.TimeIndexing.time_iloc",
        "number": 0,
        "param_names": [
            "shape",
            "indexer_type"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ],
            [
                "'scalar'",
                "'bool'",
                "'slice'",
                "'list'",
                "'function'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "4e7262aec0ddddcf2cf6befd225168aa1e9f52e0ebe945dc373d7bab9c5e494c",
        "warmup_time": -1
    },
    "benchmarks.TimeIndexing.time_loc": {
        "code": "class TimeIndexing:\n    def time_loc(self, shape, indexer_type):\n        execute(self.df.loc[self.indexer])\n\n    def setup(self, shape, indexer_type):\n        self.df = generate_dataframe(ASV_USE_IMPL, \"int\", *shape, RAND_LOW, RAND_HIGH)\n        if indexer_type == \"bool\":\n            self.indexer = [False, True] * (shape[0] // 2)\n        elif indexer_type == \"scalar\":\n            self.indexer = shape[0] // 2\n        elif indexer_type == \"slice\":\n            self.indexer = slice(0, shape[0], 2)\n        elif indexer_type == \"list\":\n            self.indexer = [x for x in range(shape[0])]\n        elif indexer_type == \"function\":\n            self.indexer = lambda df: df.index[::-2]",
        "min_run_count": 2,
        "name": "benchmarks.TimeIndexing.time_loc",
        "number": 0,
        "param_names": [
            "shape",
            "indexer_type"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ],
            [
                "'scalar'",
                "'bool'",
                "'slice'",
                "'list'",
                "'function'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "7b6fd37f862f1a881d3f8e46bfd517d56f952ee9725a393f5c66ef88ba8a3a38",
        "warmup_time": -1
    },
    "benchmarks.TimeInsert.time_insert_qc": {
        "code": "class TimeInsert:\n    def time_insert_qc(self, *args, **kwargs):\n        self.df.insert(loc=self.iloc, column=random_string(), value=self.item)\n        execute(self.df)\n\nclass BaseTimeSetItem:\n    def setup(self, shape, item_length, loc, is_equal_indices):\n        self.df = generate_dataframe(\n            ASV_USE_IMPL, \"int\", *shape, RAND_LOW, RAND_HIGH\n        ).copy()\n        self.loc, self.iloc = self.get_loc(\n            self.df, loc, item_length=item_length, axis=1\n        )\n    \n        self.item = self.df[self.loc] + 1\n        self.item_raw = self.item.to_numpy()\n        if not is_equal_indices:\n            self.item.index = reversed(self.item.index)",
        "min_run_count": 2,
        "name": "benchmarks.TimeInsert.time_insert_qc",
        "number": 0,
        "param_names": [
            "shape",
            "item_length",
            "loc",
            "is_equal_indices"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ],
            [
                "1"
            ],
            [
                "'zero'",
                "'middle'",
                "'last'"
            ],
            [
                "True",
                "False"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "6a36fc5cdb39f04cd6acb87bb95abcbb19bda4f85209e8d039c523287bdbf7a2",
        "warmup_time": -1
    },
    "benchmarks.TimeInsert.time_insert_raw": {
        "code": "class TimeInsert:\n    def time_insert_raw(self, *args, **kwargs):\n        self.df.insert(loc=self.iloc, column=random_string(), value=self.item_raw)\n        execute(self.df)\n\nclass BaseTimeSetItem:\n    def setup(self, shape, item_length, loc, is_equal_indices):\n        self.df = generate_dataframe(\n            ASV_USE_IMPL, \"int\", *shape, RAND_LOW, RAND_HIGH\n        ).copy()\n        self.loc, self.iloc = self.get_loc(\n            self.df, loc, item_length=item_length, axis=1\n        )\n    \n        self.item = self.df[self.loc] + 1\n        self.item_raw = self.item.to_numpy()\n        if not is_equal_indices:\n            self.item.index = reversed(self.item.index)",
        "min_run_count": 2,
        "name": "benchmarks.TimeInsert.time_insert_raw",
        "number": 0,
        "param_names": [
            "shape",
            "item_length",
            "loc",
            "is_equal_indices"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ],
            [
                "1"
            ],
            [
                "'zero'",
                "'middle'",
                "'last'"
            ],
            [
                "True",
                "False"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "3df7c66b76b70618061bcfe51d0d0b9e10c21a48362cc453908a653cbe2fd176",
        "warmup_time": -1
    },
    "benchmarks.TimeJoin.time_join": {
        "code": "class TimeJoin:\n    def time_join(self, shapes, how, sort):\n        # join dataframes on index to get the predictable shape\n        execute(self.df1.join(self.df2, how=how, lsuffix=\"left_\", sort=sort))\n\n    def setup(self, shapes, how, sort):\n        self.df1 = generate_dataframe(\n            ASV_USE_IMPL, \"int\", *shapes[0], RAND_LOW, RAND_HIGH\n        )\n        self.df2 = generate_dataframe(\n            ASV_USE_IMPL, \"int\", *shapes[1], RAND_LOW, RAND_HIGH\n        )",
        "min_run_count": 2,
        "name": "benchmarks.TimeJoin.time_join",
        "number": 0,
        "param_names": [
            "shapes",
            "how",
            "sort"
        ],
        "params": [
            [
                "((5000, 5000), (5000, 5000))",
                "((500000, 20), (1000000, 10))"
            ],
            [
                "'left'",
                "'inner'"
            ],
            [
                "False"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "1aebc2ab80819fc05dfc2e9db051894b755bc1f69150780b6a4541019f1728dc",
        "warmup_time": -1
    },
    "benchmarks.TimeMerge.time_merge": {
        "code": "class TimeMerge:\n    def time_merge(self, shapes, how, sort):\n        # merge dataframes by index to get the predictable shape\n        execute(\n            self.df1.merge(\n                self.df2, left_index=True, right_index=True, how=how, sort=sort\n            )\n        )\n\n    def setup(self, shapes, how, sort):\n        self.df1 = generate_dataframe(\n            ASV_USE_IMPL, \"int\", *shapes[0], RAND_LOW, RAND_HIGH\n        )\n        self.df2 = generate_dataframe(\n            ASV_USE_IMPL, \"int\", *shapes[1], RAND_LOW, RAND_HIGH\n        )",
        "min_run_count": 2,
        "name": "benchmarks.TimeMerge.time_merge",
        "number": 0,
        "param_names": [
            "shapes",
            "how",
            "sort"
        ],
        "params": [
            [
                "((5000, 5000), (5000, 5000))",
                "((500000, 20), (1000000, 10))"
            ],
            [
                "'left'",
                "'inner'"
            ],
            [
                "False"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "5dd956fb7db1d5b0a96e59375c5e98318f9f43faa97b9b6562cf41d9445c9d9a",
        "warmup_time": -1
    },
    "benchmarks.TimeMultiIndexing.time_multiindex_loc": {
        "code": "class TimeMultiIndexing:\n    def time_multiindex_loc(self, shape):\n        execute(\n            self.df.loc[\n                self.df.index[2] : self.df.index[-2],\n                self.df.columns[2] : self.df.columns[-2],\n            ]\n        )\n\n    def setup(self, shape):\n        df = generate_dataframe(ASV_USE_IMPL, \"int\", *shape, RAND_LOW, RAND_HIGH)\n    \n        index = pd.MultiIndex.from_product([df.index[: shape[0] // 2], [\"bar\", \"foo\"]])\n        columns = pd.MultiIndex.from_product(\n            [df.columns[: shape[1] // 2], [\"buz\", \"fuz\"]]\n        )\n    \n        df.index = index\n        df.columns = columns\n    \n        self.df = df.sort_index(axis=1)",
        "min_run_count": 2,
        "name": "benchmarks.TimeMultiIndexing.time_multiindex_loc",
        "number": 0,
        "param_names": [
            "shape"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "80e00dd183fe0c4a8126be25f72361ee20f99910b9769b7b35381e106e45dc4f",
        "warmup_time": -1
    },
    "benchmarks.TimeProperties.time_columns": {
        "code": "class TimeProperties:\n    def time_columns(self, shape):\n        return self.df.columns\n\n    def setup(self, shape):\n        self.df = generate_dataframe(ASV_USE_IMPL, \"int\", *shape, RAND_LOW, RAND_HIGH)",
        "min_run_count": 2,
        "name": "benchmarks.TimeProperties.time_columns",
        "number": 0,
        "param_names": [
            "shape"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "effb7b0976e7b3b0ee005ca8318ad48fb5588e1836d8ec6535810367e46725a8",
        "warmup_time": -1
    },
    "benchmarks.TimeProperties.time_index": {
        "code": "class TimeProperties:\n    def time_index(self, shape):\n        return self.df.index\n\n    def setup(self, shape):\n        self.df = generate_dataframe(ASV_USE_IMPL, \"int\", *shape, RAND_LOW, RAND_HIGH)",
        "min_run_count": 2,
        "name": "benchmarks.TimeProperties.time_index",
        "number": 0,
        "param_names": [
            "shape"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "487a3dbef05f696142e0534475d8373a9075dd28d31de0cf3449ca7a95ffb7b2",
        "warmup_time": -1
    },
    "benchmarks.TimeProperties.time_shape": {
        "code": "class TimeProperties:\n    def time_shape(self, shape):\n        return self.df.shape\n\n    def setup(self, shape):\n        self.df = generate_dataframe(ASV_USE_IMPL, \"int\", *shape, RAND_LOW, RAND_HIGH)",
        "min_run_count": 2,
        "name": "benchmarks.TimeProperties.time_shape",
        "number": 0,
        "param_names": [
            "shape"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b8ce432425cc9aa74975357694dfa8cb95a0553d19b8daf97522757a0a607904",
        "warmup_time": -1
    },
    "benchmarks.TimeSetItem.time_setitem_qc": {
        "code": "class TimeSetItem:\n    def time_setitem_qc(self, *args, **kwargs):\n        self.df[self.loc] = self.item\n        execute(self.df)\n\nclass BaseTimeSetItem:\n    def setup(self, shape, item_length, loc, is_equal_indices):\n        self.df = generate_dataframe(\n            ASV_USE_IMPL, \"int\", *shape, RAND_LOW, RAND_HIGH\n        ).copy()\n        self.loc, self.iloc = self.get_loc(\n            self.df, loc, item_length=item_length, axis=1\n        )\n    \n        self.item = self.df[self.loc] + 1\n        self.item_raw = self.item.to_numpy()\n        if not is_equal_indices:\n            self.item.index = reversed(self.item.index)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSetItem.time_setitem_qc",
        "number": 0,
        "param_names": [
            "shape",
            "item_length",
            "loc",
            "is_equal_indices"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ],
            [
                "1"
            ],
            [
                "'zero'",
                "'middle'",
                "'last'"
            ],
            [
                "True",
                "False"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "1dcdd3d591970df5bad4e794a6b247d6b11cd6be21cf344809de06747fafbe17",
        "warmup_time": -1
    },
    "benchmarks.TimeSetItem.time_setitem_raw": {
        "code": "class TimeSetItem:\n    def time_setitem_raw(self, *args, **kwargs):\n        self.df[self.loc] = self.item_raw\n        execute(self.df)\n\nclass BaseTimeSetItem:\n    def setup(self, shape, item_length, loc, is_equal_indices):\n        self.df = generate_dataframe(\n            ASV_USE_IMPL, \"int\", *shape, RAND_LOW, RAND_HIGH\n        ).copy()\n        self.loc, self.iloc = self.get_loc(\n            self.df, loc, item_length=item_length, axis=1\n        )\n    \n        self.item = self.df[self.loc] + 1\n        self.item_raw = self.item.to_numpy()\n        if not is_equal_indices:\n            self.item.index = reversed(self.item.index)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSetItem.time_setitem_raw",
        "number": 0,
        "param_names": [
            "shape",
            "item_length",
            "loc",
            "is_equal_indices"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ],
            [
                "1"
            ],
            [
                "'zero'",
                "'middle'",
                "'last'"
            ],
            [
                "True",
                "False"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "6cae5f1f7d662915a35e36dc638b77707287a9bc5f67309f89f75fd57743ef01",
        "warmup_time": -1
    },
    "benchmarks.TimeSortValues.time_sort_values": {
        "code": "class TimeSortValues:\n    def time_sort_values(self, shape, columns_number, ascending_list):\n        execute(self.df.sort_values(self.columns, ascending=self.ascending))\n\n    def setup(self, shape, columns_number, ascending_list):\n        self.df = generate_dataframe(ASV_USE_IMPL, \"int\", *shape, RAND_LOW, RAND_HIGH)\n        self.columns = random_columns(self.df.columns, columns_number)\n        self.ascending = (\n            random_booleans(columns_number)\n            if ascending_list\n            else bool(random_booleans(1)[0])\n        )",
        "min_run_count": 2,
        "name": "benchmarks.TimeSortValues.time_sort_values",
        "number": 0,
        "param_names": [
            "shape",
            "columns_number",
            "ascending_list"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ],
            [
                "1",
                "2",
                "10",
                "100"
            ],
            [
                "False",
                "True"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "5cf2258ccb3d7833acd5e9765b8023fdbf0d27fd70e540f457f576be26c37ec9",
        "warmup_time": -1
    },
    "benchmarks.TimeValueCountsFrame.time_value_counts": {
        "code": "class TimeValueCountsFrame:\n    def time_value_counts(self, *args, **kwargs):\n        execute(self.df.value_counts(subset=self.subset))\n\nclass BaseTimeValueCounts:\n    def setup(self, shape, ngroups=5, subset=\"all\"):\n        try:\n            subset = self.subset_params[subset]\n        except KeyError:\n            raise KeyError(\n                f\"Invalid value for 'subset={subset}'. Allowed: {list(self.subset_params.keys())}\"\n            )\n        ncols = subset(shape)\n        self.df, _ = generate_dataframe(\n            ASV_USE_IMPL,\n            \"int\",\n            *shape,\n            RAND_LOW,\n            RAND_HIGH,\n            groupby_ncols=ncols,\n            count_groups=ngroups,\n        )\n        self.subset = self.df.columns[:ncols].tolist()",
        "min_run_count": 2,
        "name": "benchmarks.TimeValueCountsFrame.time_value_counts",
        "number": 0,
        "param_names": [
            "shape",
            "ngroups",
            "subset"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ],
            [
                "100",
                "<function <lambda> at 0x7f2abcd06820>"
            ],
            [
                "'all'",
                "'half'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b72395b9619d84b100d7a01a619544bd08a7e8b1b3ebb42c6a795c1338c5f282",
        "warmup_time": -1
    },
    "benchmarks.TimeValueCountsSeries.time_value_counts": {
        "code": "class TimeValueCountsSeries:\n    def time_value_counts(self, shape, ngroups, bins):\n        execute(self.df.value_counts(bins=bins))\n\n    def setup(self, shape, ngroups, bins):\n        super().setup(ngroups=ngroups, shape=shape)\n        self.df = self.df.iloc[:, 0]",
        "min_run_count": 2,
        "name": "benchmarks.TimeValueCountsSeries.time_value_counts",
        "number": 0,
        "param_names": [
            "shape",
            "ngroups",
            "bins"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ],
            [
                "100",
                "<function <lambda> at 0x7f2abcd06820>"
            ],
            [
                "None",
                "3"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "cd8cd69d559c36bd90b816fcb0fb67588091a5ba8715a620666d07ace8e7c519",
        "warmup_time": -1
    },
    "io.csv.TimeReadCsvSkiprows.time_skiprows": {
        "code": "class TimeReadCsvSkiprows:\n    def time_skiprows(self, test_filenames, shape, skiprows):\n        execute(\n            IMPL[ASV_USE_IMPL].read_csv(\n                test_filenames[self.shape_id], skiprows=skiprows\n            )\n        )\n\nclass BaseReadCsv:\n    def setup(self, test_filenames, shape, *args, **kwargs):\n        self.shape_id = get_shape_id(shape)\n\n    def setup_cache(self, test_filename=\"io_test_file\"):\n        test_filenames = {}\n        for shape in UNARY_OP_DATA_SIZE[ASV_DATASET_SIZE]:\n            shape_id = get_shape_id(shape)\n            test_filenames[shape_id] = f\"{test_filename}_{shape_id}.csv\"\n            df = generate_dataframe(\"pandas\", \"str_int\", *shape, RAND_LOW, RAND_HIGH)\n            df.to_csv(test_filenames[shape_id], index=False)\n    \n        return test_filenames",
        "min_run_count": 2,
        "name": "io.csv.TimeReadCsvSkiprows.time_skiprows",
        "number": 0,
        "param_names": [
            "shape",
            "skiprows"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ],
            [
                "None",
                "<function TimeReadCsvSkiprows.<lambda> at 0x7f2ccd1e5820>",
                "array([  1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,\n        14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,\n        27,  28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,\n        40,  41,  42,  43,  44,  45,  46,  47,  48,  49,  50,  51,  52,\n        53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,  64,  65,\n        66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,\n        79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,\n        92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 102, 103, 104,\n       105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117,\n       118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n       131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,\n       144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156,\n       157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169,\n       170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182,\n       183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195,\n       196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208,\n       209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221,\n       222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234,\n       235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247,\n       248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260,\n       261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273,\n       274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286,\n       287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299,\n       300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312,\n       313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325,\n       326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338,\n       339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351,\n       352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364,\n       365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377,\n       378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390,\n       391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403,\n       404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416,\n       417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429,\n       430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442,\n       443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455,\n       456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468,\n       469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481,\n       482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494,\n       495, 496, 497, 498, 499])",
                "array([   1,    3,    5, ..., 4995, 4997, 4999])"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "setup_cache_key": "/modin/asv_bench/benchmarks/io/csv.py:36",
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "fa9e2d29536162082c54b4a898b4b6533b23b110d8d8718fc240a97965468ea0",
        "warmup_time": -1
    },
    "version": 2
}