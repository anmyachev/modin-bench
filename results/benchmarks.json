{
    "benchmarks.TimeArithmetic.time_apply": {
        "code": "class <locals>:\n    def real_executor(*arg, **kwargs):\n        return func(*arg, **kwargs).shape\n\nclass TimeArithmetic:\n    def setup(self, data_size, axis):\n        self.df = generate_dataframe(\n            ASV_USE_IMPL, \"int\", data_size[1], data_size[0], RAND_LOW, RAND_HIGH\n        )",
        "min_run_count": 2,
        "name": "benchmarks.TimeArithmetic.time_apply",
        "number": 0,
        "param_names": [
            "data_size",
            "axis"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ],
            [
                "0",
                "1"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "43b4c72e5c1c3632693e56077e4293f02f0315bf7533dc84201074bf0e7d699f",
        "warmup_time": -1
    },
    "benchmarks.TimeArithmetic.time_mean": {
        "code": "class <locals>:\n    def real_executor(*arg, **kwargs):\n        return func(*arg, **kwargs).shape\n\nclass TimeArithmetic:\n    def setup(self, data_size, axis):\n        self.df = generate_dataframe(\n            ASV_USE_IMPL, \"int\", data_size[1], data_size[0], RAND_LOW, RAND_HIGH\n        )",
        "min_run_count": 2,
        "name": "benchmarks.TimeArithmetic.time_mean",
        "number": 0,
        "param_names": [
            "data_size",
            "axis"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ],
            [
                "0",
                "1"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "43b4c72e5c1c3632693e56077e4293f02f0315bf7533dc84201074bf0e7d699f",
        "warmup_time": -1
    },
    "benchmarks.TimeArithmetic.time_median": {
        "code": "class <locals>:\n    def real_executor(*arg, **kwargs):\n        return func(*arg, **kwargs).shape\n\nclass TimeArithmetic:\n    def setup(self, data_size, axis):\n        self.df = generate_dataframe(\n            ASV_USE_IMPL, \"int\", data_size[1], data_size[0], RAND_LOW, RAND_HIGH\n        )",
        "min_run_count": 2,
        "name": "benchmarks.TimeArithmetic.time_median",
        "number": 0,
        "param_names": [
            "data_size",
            "axis"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ],
            [
                "0",
                "1"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "43b4c72e5c1c3632693e56077e4293f02f0315bf7533dc84201074bf0e7d699f",
        "warmup_time": -1
    },
    "benchmarks.TimeArithmetic.time_nunique": {
        "code": "class <locals>:\n    def real_executor(*arg, **kwargs):\n        return func(*arg, **kwargs).shape\n\nclass TimeArithmetic:\n    def setup(self, data_size, axis):\n        self.df = generate_dataframe(\n            ASV_USE_IMPL, \"int\", data_size[1], data_size[0], RAND_LOW, RAND_HIGH\n        )",
        "min_run_count": 2,
        "name": "benchmarks.TimeArithmetic.time_nunique",
        "number": 0,
        "param_names": [
            "data_size",
            "axis"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ],
            [
                "0",
                "1"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "43b4c72e5c1c3632693e56077e4293f02f0315bf7533dc84201074bf0e7d699f",
        "warmup_time": -1
    },
    "benchmarks.TimeArithmetic.time_sum": {
        "code": "class <locals>:\n    def real_executor(*arg, **kwargs):\n        return func(*arg, **kwargs).shape\n\nclass TimeArithmetic:\n    def setup(self, data_size, axis):\n        self.df = generate_dataframe(\n            ASV_USE_IMPL, \"int\", data_size[1], data_size[0], RAND_LOW, RAND_HIGH\n        )",
        "min_run_count": 2,
        "name": "benchmarks.TimeArithmetic.time_sum",
        "number": 0,
        "param_names": [
            "data_size",
            "axis"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ],
            [
                "0",
                "1"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "43b4c72e5c1c3632693e56077e4293f02f0315bf7533dc84201074bf0e7d699f",
        "warmup_time": -1
    },
    "benchmarks.TimeBinaryOp.time_binary_op": {
        "code": "class <locals>:\n    def real_executor(*arg, **kwargs):\n        return func(*arg, **kwargs).shape\n\nclass TimeBinaryOp:\n    def setup(self, data_size, binary_op, axis):\n        # shape for generate_dataframe: first - ncols, second - nrows\n        self.df1 = generate_dataframe(\n            ASV_USE_IMPL, \"int\", data_size[1], data_size[0], RAND_LOW, RAND_HIGH\n        )\n        self.df2 = generate_dataframe(\n            ASV_USE_IMPL, \"int\", data_size[3], data_size[2], RAND_LOW, RAND_HIGH\n        )\n        self.op = getattr(self.df1, binary_op)",
        "min_run_count": 2,
        "name": "benchmarks.TimeBinaryOp.time_binary_op",
        "number": 0,
        "param_names": [
            "data_size",
            "binary_op",
            "axis"
        ],
        "params": [
            [
                "(5000, 5000, 5000, 5000)",
                "(500000, 20, 1000000, 10)"
            ],
            [
                "'mul'"
            ],
            [
                "0",
                "1"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "3f19ec8d893657c61163dc5261c643085d0dde1c4187b43a15db5eba595992e0",
        "warmup_time": -1
    },
    "benchmarks.TimeConcat.time_concat": {
        "code": "class <locals>:\n    def real_executor(*arg, **kwargs):\n        return func(*arg, **kwargs).shape\n\nclass TimeConcat:\n    def setup(self, data_size, how, axis):\n        # shape for generate_dataframe: first - ncols, second - nrows\n        self.df1 = generate_dataframe(\n            ASV_USE_IMPL, \"int\", data_size[1], data_size[0], RAND_LOW, RAND_HIGH\n        )\n        self.df2 = generate_dataframe(\n            ASV_USE_IMPL, \"int\", data_size[3], data_size[2], RAND_LOW, RAND_HIGH\n        )",
        "min_run_count": 2,
        "name": "benchmarks.TimeConcat.time_concat",
        "number": 0,
        "param_names": [
            "data_size",
            "how",
            "axis"
        ],
        "params": [
            [
                "(5000, 5000, 5000, 5000)",
                "(500000, 20, 1000000, 10)"
            ],
            [
                "'inner'"
            ],
            [
                "0",
                "1"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "96b48dfc8903b0c4aec84b7e1fff8b21e17a2b0ad1bd79d5d2de13afb37bf71b",
        "warmup_time": -1
    },
    "benchmarks.TimeGroupByDefaultAggregations.time_groupby_count": {
        "code": "class <locals>:\n    def real_executor(*arg, **kwargs):\n        return func(*arg, **kwargs).shape\n\nclass TimeGroupByDefaultAggregations:\n    def setup(self, data_size):\n        self.df = generate_dataframe(\n            ASV_USE_IMPL, \"int\", data_size[1], data_size[0], RAND_LOW, RAND_HIGH\n        )\n        self.groupby_column = self.df.columns[0]",
        "min_run_count": 2,
        "name": "benchmarks.TimeGroupByDefaultAggregations.time_groupby_count",
        "number": 0,
        "param_names": [
            "data_size"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "1e301cb86cc10c2bbc8963d576eee093bf4ce41fa95d6c9ce3b6a964624cd957",
        "warmup_time": -1
    },
    "benchmarks.TimeGroupByDefaultAggregations.time_groupby_mean": {
        "code": "class <locals>:\n    def real_executor(*arg, **kwargs):\n        return func(*arg, **kwargs).shape\n\nclass TimeGroupByDefaultAggregations:\n    def setup(self, data_size):\n        self.df = generate_dataframe(\n            ASV_USE_IMPL, \"int\", data_size[1], data_size[0], RAND_LOW, RAND_HIGH\n        )\n        self.groupby_column = self.df.columns[0]",
        "min_run_count": 2,
        "name": "benchmarks.TimeGroupByDefaultAggregations.time_groupby_mean",
        "number": 0,
        "param_names": [
            "data_size"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "1e301cb86cc10c2bbc8963d576eee093bf4ce41fa95d6c9ce3b6a964624cd957",
        "warmup_time": -1
    },
    "benchmarks.TimeGroupByDefaultAggregations.time_groupby_size": {
        "code": "class <locals>:\n    def real_executor(*arg, **kwargs):\n        return func(*arg, **kwargs).shape\n\nclass TimeGroupByDefaultAggregations:\n    def setup(self, data_size):\n        self.df = generate_dataframe(\n            ASV_USE_IMPL, \"int\", data_size[1], data_size[0], RAND_LOW, RAND_HIGH\n        )\n        self.groupby_column = self.df.columns[0]",
        "min_run_count": 2,
        "name": "benchmarks.TimeGroupByDefaultAggregations.time_groupby_size",
        "number": 0,
        "param_names": [
            "data_size"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "1e301cb86cc10c2bbc8963d576eee093bf4ce41fa95d6c9ce3b6a964624cd957",
        "warmup_time": -1
    },
    "benchmarks.TimeGroupByDefaultAggregations.time_groupby_sum": {
        "code": "class <locals>:\n    def real_executor(*arg, **kwargs):\n        return func(*arg, **kwargs).shape\n\nclass TimeGroupByDefaultAggregations:\n    def setup(self, data_size):\n        self.df = generate_dataframe(\n            ASV_USE_IMPL, \"int\", data_size[1], data_size[0], RAND_LOW, RAND_HIGH\n        )\n        self.groupby_column = self.df.columns[0]",
        "min_run_count": 2,
        "name": "benchmarks.TimeGroupByDefaultAggregations.time_groupby_sum",
        "number": 0,
        "param_names": [
            "data_size"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "1e301cb86cc10c2bbc8963d576eee093bf4ce41fa95d6c9ce3b6a964624cd957",
        "warmup_time": -1
    },
    "benchmarks.TimeInsert.time_insert_qc": {
        "code": "class <locals>:\n    def real_executor(*arg, **kwargs):\n        return func(*arg, **kwargs).shape\n\nclass BaseTimeSetItem:\n    def setup(self, data_size, item_length, loc, is_equal_indices):\n        self.df = generate_dataframe(\n            ASV_USE_IMPL, \"int\", data_size[1], data_size[0], RAND_LOW, RAND_HIGH\n        ).copy()\n        self.loc, self.iloc = self.get_loc(\n            self.df, loc, item_length=item_length, axis=1\n        )\n    \n        self.item = self.df[self.loc] + 1\n        self.item_raw = self.item.to_numpy()\n        if not is_equal_indices:\n            self.item.index = reversed(self.item.index)",
        "min_run_count": 2,
        "name": "benchmarks.TimeInsert.time_insert_qc",
        "number": 0,
        "param_names": [
            "data_size",
            "item_length",
            "loc",
            "is_equal_indices"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ],
            [
                "1"
            ],
            [
                "'zero'",
                "'middle'",
                "'last'"
            ],
            [
                "True",
                "False"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "e8fa27b21067aab4c51cf903c6ee03ba1bb8e8a61f363e4de1cf736ccfbc49eb",
        "warmup_time": -1
    },
    "benchmarks.TimeInsert.time_insert_raw": {
        "code": "class <locals>:\n    def real_executor(*arg, **kwargs):\n        return func(*arg, **kwargs).shape\n\nclass BaseTimeSetItem:\n    def setup(self, data_size, item_length, loc, is_equal_indices):\n        self.df = generate_dataframe(\n            ASV_USE_IMPL, \"int\", data_size[1], data_size[0], RAND_LOW, RAND_HIGH\n        ).copy()\n        self.loc, self.iloc = self.get_loc(\n            self.df, loc, item_length=item_length, axis=1\n        )\n    \n        self.item = self.df[self.loc] + 1\n        self.item_raw = self.item.to_numpy()\n        if not is_equal_indices:\n            self.item.index = reversed(self.item.index)",
        "min_run_count": 2,
        "name": "benchmarks.TimeInsert.time_insert_raw",
        "number": 0,
        "param_names": [
            "data_size",
            "item_length",
            "loc",
            "is_equal_indices"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ],
            [
                "1"
            ],
            [
                "'zero'",
                "'middle'",
                "'last'"
            ],
            [
                "True",
                "False"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "e8fa27b21067aab4c51cf903c6ee03ba1bb8e8a61f363e4de1cf736ccfbc49eb",
        "warmup_time": -1
    },
    "benchmarks.TimeJoin.time_join": {
        "code": "class <locals>:\n    def real_executor(*arg, **kwargs):\n        return func(*arg, **kwargs).shape\n\nclass TimeJoin:\n    def setup(self, data_size, how, sort):\n        self.df1 = generate_dataframe(\n            ASV_USE_IMPL, \"int\", data_size[1], data_size[0], RAND_LOW, RAND_HIGH\n        )\n        self.df2 = generate_dataframe(\n            ASV_USE_IMPL, \"int\", data_size[3], data_size[2], RAND_LOW, RAND_HIGH\n        )",
        "min_run_count": 2,
        "name": "benchmarks.TimeJoin.time_join",
        "number": 0,
        "param_names": [
            "data_size",
            "how",
            "sort"
        ],
        "params": [
            [
                "(5000, 5000, 5000, 5000)",
                "(500000, 20, 1000000, 10)"
            ],
            [
                "'left'",
                "'inner'"
            ],
            [
                "False"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "927528b006d5bd008cf049f1d78e4a9c9513d203f29a314e28339b1f760bbe63",
        "warmup_time": -1
    },
    "benchmarks.TimeMerge.time_merge": {
        "code": "class <locals>:\n    def real_executor(*arg, **kwargs):\n        return func(*arg, **kwargs).shape\n\nclass TimeMerge:\n    def setup(self, data_size, how, sort):\n        self.df1 = generate_dataframe(\n            ASV_USE_IMPL, \"int\", data_size[1], data_size[0], RAND_LOW, RAND_HIGH\n        )\n        self.df2 = generate_dataframe(\n            ASV_USE_IMPL, \"int\", data_size[3], data_size[2], RAND_LOW, RAND_HIGH\n        )",
        "min_run_count": 2,
        "name": "benchmarks.TimeMerge.time_merge",
        "number": 0,
        "param_names": [
            "data_size",
            "how",
            "sort"
        ],
        "params": [
            [
                "(5000, 5000, 5000, 5000)",
                "(500000, 20, 1000000, 10)"
            ],
            [
                "'left'",
                "'inner'"
            ],
            [
                "False"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "868cd019ef2cc92d03561118ff8a01e6b094f83ac2cc34014adc5b5985cfc209",
        "warmup_time": -1
    },
    "benchmarks.TimeMultiColumnGroupby.time_groupby_agg_mean": {
        "code": "class <locals>:\n    def real_executor(*arg, **kwargs):\n        return func(*arg, **kwargs).shape\n\nclass TimeMultiColumnGroupby:\n    def setup(self, data_size, count_columns):\n        self.df = generate_dataframe(\n            ASV_USE_IMPL, \"int\", data_size[1], data_size[0], RAND_LOW, RAND_HIGH\n        )\n        self.groupby_columns = [col for col in self.df.columns[:count_columns]]",
        "min_run_count": 2,
        "name": "benchmarks.TimeMultiColumnGroupby.time_groupby_agg_mean",
        "number": 0,
        "param_names": [
            "data_size",
            "count_columns"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ],
            [
                "6"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "349c0df77cb7dfb53b75a79acd5a6be58c9124bfceab14f2ae19d8848b7ff3e9",
        "warmup_time": -1
    },
    "benchmarks.TimeMultiColumnGroupby.time_groupby_agg_quan": {
        "code": "class <locals>:\n    def real_executor(*arg, **kwargs):\n        return func(*arg, **kwargs).shape\n\nclass TimeMultiColumnGroupby:\n    def setup(self, data_size, count_columns):\n        self.df = generate_dataframe(\n            ASV_USE_IMPL, \"int\", data_size[1], data_size[0], RAND_LOW, RAND_HIGH\n        )\n        self.groupby_columns = [col for col in self.df.columns[:count_columns]]",
        "min_run_count": 2,
        "name": "benchmarks.TimeMultiColumnGroupby.time_groupby_agg_quan",
        "number": 0,
        "param_names": [
            "data_size",
            "count_columns"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ],
            [
                "6"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "349c0df77cb7dfb53b75a79acd5a6be58c9124bfceab14f2ae19d8848b7ff3e9",
        "warmup_time": -1
    },
    "benchmarks.TimeSetItem.time_setitem_qc": {
        "code": "class <locals>:\n    def real_executor(*arg, **kwargs):\n        return func(*arg, **kwargs).shape\n\nclass BaseTimeSetItem:\n    def setup(self, data_size, item_length, loc, is_equal_indices):\n        self.df = generate_dataframe(\n            ASV_USE_IMPL, \"int\", data_size[1], data_size[0], RAND_LOW, RAND_HIGH\n        ).copy()\n        self.loc, self.iloc = self.get_loc(\n            self.df, loc, item_length=item_length, axis=1\n        )\n    \n        self.item = self.df[self.loc] + 1\n        self.item_raw = self.item.to_numpy()\n        if not is_equal_indices:\n            self.item.index = reversed(self.item.index)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSetItem.time_setitem_qc",
        "number": 0,
        "param_names": [
            "data_size",
            "item_length",
            "loc",
            "is_equal_indices"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ],
            [
                "1"
            ],
            [
                "'zero'",
                "'middle'",
                "'last'"
            ],
            [
                "True",
                "False"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "e8fa27b21067aab4c51cf903c6ee03ba1bb8e8a61f363e4de1cf736ccfbc49eb",
        "warmup_time": -1
    },
    "benchmarks.TimeSetItem.time_setitem_raw": {
        "code": "class <locals>:\n    def real_executor(*arg, **kwargs):\n        return func(*arg, **kwargs).shape\n\nclass BaseTimeSetItem:\n    def setup(self, data_size, item_length, loc, is_equal_indices):\n        self.df = generate_dataframe(\n            ASV_USE_IMPL, \"int\", data_size[1], data_size[0], RAND_LOW, RAND_HIGH\n        ).copy()\n        self.loc, self.iloc = self.get_loc(\n            self.df, loc, item_length=item_length, axis=1\n        )\n    \n        self.item = self.df[self.loc] + 1\n        self.item_raw = self.item.to_numpy()\n        if not is_equal_indices:\n            self.item.index = reversed(self.item.index)",
        "min_run_count": 2,
        "name": "benchmarks.TimeSetItem.time_setitem_raw",
        "number": 0,
        "param_names": [
            "data_size",
            "item_length",
            "loc",
            "is_equal_indices"
        ],
        "params": [
            [
                "(5000, 5000)",
                "(1000000, 10)"
            ],
            [
                "1"
            ],
            [
                "'zero'",
                "'middle'",
                "'last'"
            ],
            [
                "True",
                "False"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "e8fa27b21067aab4c51cf903c6ee03ba1bb8e8a61f363e4de1cf736ccfbc49eb",
        "warmup_time": -1
    },
    "version": 2
}